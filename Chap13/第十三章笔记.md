# 第十三章笔记

- 当C语言遇到长度为n的字符串时，会把字符串分配到n+1的空间里，因为结尾有'\0'

- char *p;

  p = "abc"

  p"abc"[0]

  p"abc"[1]

  p"abc"[2]

  这么做不是复制“abc”这个字符串，而是指向这个字符。

  

- 声明字符串的常见方式

  ```c
  #define STR_LEN 80
  char str[STR_LEN+1]
  ```

  

- 如果初始化太短以至于不能填满字符串，编译器就会添加空字符

- char date[] = "June 14"    这是一个字符数组

  char  *date = "June 14"   一个指向字符串字面量的指针

  

- scanf("%s", str)

  scanf函数会跳过空白字符，然后读入字符，并且把读入的字符存储到str中,直到遇到空白字符为止

  

- gets:

  1. 不会在开始读字符串之前 跳过空白字符

  2. 会持续读入直到找到换行符才停止

     

- ```c
  char sentence[sentence_len+1]
  scanf("%s", sentence)
  get(sentence)
  ```

  假如输入——“To C, or not to C"

  scanf: 传入"To", 再次被调用时，会跳过空格

  get:直接传入“To C, or not to C"

  

- read_line函数

  ```c
  int read_line(char str[], int n)
  {
      char ch;
      int i = 0;
      while((ch = getchar()) != '\n')
          if (i < n)
              str[i++] = ch;
      str[i] = '\0'; /*一定要放个空字符号*/
      return i;
  }
  ```

  

- 一个函数统计字符串中空格的数量

  ```c
  int count_spaces(const char a[])
  {
      int count = 0, i;
      for (i = 0; s[i]!='\0'; i++){
          if(s[i] == ' ')
              count++;
          return count;
      }
  }
  ```

  ```c
  int count_spaces(const char *s)
  {
      int count = 0;
      for(;*s!='\0';s++)
          if(*s==' ')
              count++;
      	return count;
  }
  ```

  

- 直接尝试对字符串进行复制或比较操作失败

  ```c
  char str1[10], str2[10];
  str1 = "abc"; /*错误*/
  str2 = str1; /*错误*/
  
  char str3[10] = "def"; /*正确*/
  
  if(str1==str2)... /*错误*/
  ```

  

- 所以我们有了<string.h>

  ```c
  #include<string.h>
  /*strcpy函数*/
  char *strcpy(char *s1, const char *s2);
  /*strcpy函数把字符串s2复制给字符串s1*/
  strcpy(str1,"abcd");
  strcpy(str2,str1);
  
  /*strcat函数*/
  char *strcat(char *s1, const char *s2);
  /*把字符串s2的内容追加到字符串s1的末尾*/
  strcat(str1, "def");
  
  /*strcmp*/
  if(strcmp(str1,str2)==0)
  
  /*strlen*/
  len = strlen("abc");
  ```

  

